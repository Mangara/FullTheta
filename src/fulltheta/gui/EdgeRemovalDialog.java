/*
 * The MIT License
 *
 * Copyright 2019 Sander Verdonschot.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package fulltheta.gui;

import fulltheta.algos.Cone;
import fulltheta.algos.Cones;
import fulltheta.algos.SpannerBuilder;
import fulltheta.algos.SpanningRatioComputer;
import fulltheta.data.Pair;
import fulltheta.data.graph.CanonicalTriangle;
import fulltheta.data.graph.Edge;
import fulltheta.data.graph.Graph;
import fulltheta.data.graph.GraphVertex;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.swing.*;

public class EdgeRemovalDialog extends javax.swing.JDialog {

    private static final int SMALL_PANEL_SIZE = 100;
    private static final int SMALL_PANEL_SPACING = 20;

    /**
     * Creates new form EdgeRemovalDialog
     */
    public EdgeRemovalDialog(java.awt.Frame parent, Edge removeEdge, GraphDrawPanel drawPanel) {
        super(parent, true);
        initComponents();

        if (drawPanel.getCones().isSimple() && drawPanel.getCones().isTheta()) {
            List<Pair<Graph, List<CanonicalTriangle>>> removalOptions = removeEdge(drawPanel.getCones(), drawPanel.getGraph(), removeEdge, drawPanel.isDirected());

            if (removalOptions.isEmpty()) {
                buildError("No removal options found for this edge.");
            } else {
                buildOptions(removalOptions, drawPanel, removeEdge);
            }
        } else {
            buildError("Edge removal is only supported for simple theta-graphs.");
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Remove Edge");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private List<Pair<Graph, List<CanonicalTriangle>>> removeEdge(Cones cones, Graph graph, Edge edge, boolean directed) {
        cones.setVertices(graph.getVertices());

        List<GraphVertex> blockAB = new ArrayList<GraphVertex>();
        List<GraphVertex> blockBA = new ArrayList<GraphVertex>();

        Cone coneAB = cones.getCone(edge.getVA(), edge.getVB());

        if (coneAB != null && cones.getClosestVertexInCone(edge.getVA(), coneAB) == edge.getVB()) {
            // Get rid of A -> B
            // Place a vertex in either corner of the canonical triangle, a little closer to A
            CanonicalTriangle canon = new CanonicalTriangle(edge.getVA(), edge.getVB(), cones);

            blockAB.add(closeTo(canon.getCorner1X(), canon.getCorner1Y(), edge.getVA(), edge.getVB()));
            blockAB.add(closeTo(canon.getCorner2X(), canon.getCorner2Y(), edge.getVA(), edge.getVB()));
        }

        Cone coneBA = cones.getCone(edge.getVB(), edge.getVA());

        if (coneBA != null && cones.getClosestVertexInCone(edge.getVB(), coneBA) == edge.getVA()) {
            // Get rid of B -> A
            // Place a vertex in either corner of the canonical triangle, a little closer to B
            CanonicalTriangle canon = new CanonicalTriangle(edge.getVB(), edge.getVA(), cones);

            blockBA.add(closeTo(canon.getCorner1X(), canon.getCorner1Y(), edge.getVB(), edge.getVA()));
            blockBA.add(closeTo(canon.getCorner2X(), canon.getCorner2Y(), edge.getVB(), edge.getVA()));
        }

        List<Pair<Graph, List<CanonicalTriangle>>> newGraphs = new ArrayList<Pair<Graph, List<CanonicalTriangle>>>();

        if (blockAB.isEmpty()) {
            for (GraphVertex v : blockBA) {
                Graph g = new Graph(graph);
                g.addVertex(v);

                // Check if the new vertex wasn't already there
                if (g.getVertices().size() == graph.getVertices().size() + 1) {
                    SpannerBuilder.buildConeSpanner(g, cones, directed);

                    newGraphs.add(new Pair<Graph, List<CanonicalTriangle>>(g, Arrays.asList(new CanonicalTriangle(edge.getVB(), v, cones))));
                }
            }
        } else if (blockBA.isEmpty()) {
            for (GraphVertex v : blockAB) {
                Graph g = new Graph(graph);
                g.addVertex(v);

                // Check if the new vertex wasn't already there
                if (g.getVertices().size() == graph.getVertices().size() + 1) {
                    SpannerBuilder.buildConeSpanner(g, cones, directed);

                    newGraphs.add(new Pair<Graph, List<CanonicalTriangle>>(g, Arrays.asList(new CanonicalTriangle(edge.getVA(), v, cones))));
                }
            }
        } else {
            // Both are non-empty: try every combination
            for (GraphVertex v1 : blockAB) {
                for (GraphVertex v2 : blockBA) {
                    Graph g = new Graph(graph);
                    g.addVertex(v1);
                    g.addVertex(v2);

                    // Check if the new vertex wasn't already there
                    if (g.getVertices().size() == graph.getVertices().size() + 2) {
                        SpannerBuilder.buildConeSpanner(g, cones, directed);

                        newGraphs.add(new Pair<Graph, List<CanonicalTriangle>>(g, Arrays.asList(new CanonicalTriangle(edge.getVA(), v1, cones), new CanonicalTriangle(edge.getVB(), v2, cones))));
                    }
                }
            }
        }

        return newGraphs;
    }

    /**
     * Returns a new vertex close to the specified coordinate, just a little
     * closer to both apex and end.
     *
     * @param x
     * @param y
     * @param apex
     * @param end
     * @return
     */
    private static GraphVertex closeTo(Double x, Double y, GraphVertex apex, GraphVertex end) {
        double epsilon = 0.00001;

        // Obtain normalized vectors pointing towards the apex and end
        double vAx = apex.getX() - x;
        double vAy = apex.getY() - y;
        double vAlength = Math.sqrt(vAx * vAx + vAy * vAy);
        vAx /= vAlength;
        vAy /= vAlength;

        double vBx = end.getX() - x;
        double vBy = end.getY() - y;
        double vBlength = Math.sqrt(vBx * vBx + vBy * vBy);
        vBx /= vBlength;
        vBy /= vBlength;

        // Move the point epsilon along both vectors
        return new GraphVertex(x + epsilon * vAx + epsilon * vBx, y + epsilon * vAy + epsilon * vBy);
    }

    private void buildError(String message) {
        JPanel centerPanel = new JPanel();
        centerPanel.setLayout(new BoxLayout(centerPanel, BoxLayout.PAGE_AXIS));
        centerPanel.add(new JLabel(message));
        centerPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JButton okButton = new JButton("OK");
        okButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                dispose();
            }
        });

        JPanel buttonPane = new JPanel();
        buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));
        buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 5, 10));
        buttonPane.add(Box.createHorizontalGlue());
        buttonPane.add(okButton);

        setLayout(new BorderLayout());
        add(centerPanel, BorderLayout.CENTER);
        add(buttonPane, BorderLayout.SOUTH);

        pack();
    }

    private void buildOptions(List<Pair<Graph, List<CanonicalTriangle>>> removalOptions, final GraphDrawPanel drawPanel, Edge removedEdge) {
        JPanel centerPanel = new JPanel();
        centerPanel.setLayout(new BoxLayout(centerPanel, BoxLayout.LINE_AXIS));
        centerPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        double currentSR = SpanningRatioComputer.computeSpanningRatio(drawPanel.getGraph());

        boolean first = true;

        for (Pair<Graph, List<CanonicalTriangle>> option : removalOptions) {
            if (first) {
                first = false;
            } else {
                centerPanel.add(Box.createHorizontalStrut(SMALL_PANEL_SPACING));
            }

            double spanningRatio = SpanningRatioComputer.computeSpanningRatio(option.getFirst());
            int percentChange = (int) (100 * (spanningRatio - currentSR) / currentSR);

            EdgeRemovalDrawPanel gdp = new EdgeRemovalDrawPanel(drawPanel, option.getFirst(), removedEdge, getZoomVertices(option), getAddedVertices(option, drawPanel.getGraph()));
            gdp.setPreferredSize(new Dimension(SMALL_PANEL_SIZE, SMALL_PANEL_SIZE));
            EdgeRemovalOptionButton button = new EdgeRemovalOptionButton(gdp, percentChange);
            centerPanel.add(button);

            // This is necessary so the anonymous inner listener class can access it
            final Graph graph = option.getFirst();
            final List<CanonicalTriangle> emptyRegions = option.getSecond();

            button.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    for (CanonicalTriangle c : emptyRegions) {
                        drawPanel.addEmptyRegion(c.toCoordinateList());
                    }
                    drawPanel.softChangeGraph(graph, false, true, true, false);

                    dispose();
                }
            });
        }

        JButton cancelButton = new JButton("Cancel");
        cancelButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                dispose();
            }
        });

        JPanel buttonPane = new JPanel();
        buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));
        buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 5, 10));
        buttonPane.add(Box.createHorizontalGlue());
        buttonPane.add(cancelButton);

        setLayout(new BorderLayout());
        add(centerPanel, BorderLayout.CENTER);
        add(buttonPane, BorderLayout.SOUTH);

        pack();
    }

    private List<GraphVertex> getZoomVertices(Pair<Graph, List<CanonicalTriangle>> option) {
        List<GraphVertex> vertices = new ArrayList<GraphVertex>();

        for (CanonicalTriangle c : option.getSecond()) {
            vertices.add(c.getApex());
            vertices.add(c.getEnd());
            vertices.add(c.getCorner1());
            vertices.add(c.getCorner2());
        }

        return vertices;
    }

    private List<GraphVertex> getAddedVertices(Pair<Graph, List<CanonicalTriangle>> option, Graph original) {
        List<GraphVertex> vertices = new ArrayList<GraphVertex>(option.getFirst().getVertices());
        vertices.removeAll(original.getVertices());
        return vertices;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
